@inject IAnswerRepository answerRepository
@inject IJSRuntime js
<div class="answers-container">
    @if (Answers == null)
    {
        <LoadingIndicatorComponent />
    }
    else
    {
        @foreach (var answer in Answers)
        {

            <div class="answer-Main">
                <SingleAnswerComponent Answer="answer" RemoveAnswer="DeleteAnswer" OnSetReplyAnswer="setResponseAnswer" ActiveResponse="IdResponseAnswer" ActiveUser="ActiveUser" />
            </div>
            <div class="answer-Main_child">
                @foreach (var childAnswer in answer.ChildAnswers)
                {
                    <div class="answer-child" style="margin-left: 20px;">
                        <SingleAnswerComponent Answer="childAnswer" RemoveAnswer="DeleteAnswer" OnSetReplyAnswer="setResponseAnswer" ActiveResponse="IdResponseAnswer" ActiveUser="ActiveUser" />
                    </div>
                }
            </div>
            @if (answer.AmountOfChildAnswers > answer.ChildAnswers.Count)
                    {
                        <div class="answer-child" style="margin-left: 20px;">
                            <button @onclick="() => GetChildAnswers(answer.IdAnswer)">
                                Show @(answer.AmountOfChildAnswers - 3) more answers
                            </button>
                        </div>
                    }
}

        <div id="list-end" class="mt-5 mb-5 p-5">
            @if (IsLoading)
            {
                <LoadingIndicatorComponent />
            }
        </div>
        <div>
            <AnswerTextComponent Text="@TextAdd" Publish="AddAnswer" Discard="discard"></AnswerTextComponent>
        </div>
    }
</div>


@code {
    /// <summary>
    /// Id pytania, do którego odnoszą się odpowiedzi.
    /// </summary>
    [Parameter]
    public int IdQuestion { get; set; }
    [Parameter]
    public List<AnswerResponseDTO> Answers { get; set; }
    /// <summary>
    /// Id odpowiedzi, do której odnosi się nowa odpowiedź.
    /// </summary>
    public int IdResponseAnswer { get; set; }
    /// <summary>
    /// Tekst pola dla nowej odpowiedzi.
    /// </summary>
    public string TextAdd { get; set; }
    /// <summary>
    /// Id aktualnie przeglądającego użytkownika.
    /// </summary>
    public int ActiveUser { get; set; }
    /// <summary>
    /// Property informujacę o stanie ładowania odpowiedzi.
    /// </summary>
    public bool IsLoading { get; set; }
    /// <summary>
    /// Property zawierające ilość odpowiedzi ładowanych na jednej stronie.
    /// </summary>
    public int PageSize { get; set; }
    /// <summary>
    /// Numer strony do której zostały załadowane odpowiedzi.
    /// </summary>
    public int PageNumber { get; set; }

    /// <summary>
    /// Pobranie Id aktualnie przeglądającego użytkownika oraz pobranie początkowej listy odpowiedzi.
    /// </summary>
    protected async override Task OnInitializedAsync()
    {
        ActiveUser = 25;
        PageSize = 10;
        Answers = new();
        await LoadMore();
        await js.InvokeVoidAsync("ScrollList.Init", "list-end", DotNetObjectReference.Create(this));
    }

    /// <summary>
    /// Metoda wysyłająca zapytanie do serwera z dodaniem nowej odpowiedzi.
    /// </summary>
    /// <param name="text">Tekst odpowiedzi</param>
    private async Task AddAnswer(string text)
    {
        AnswerResponseDTO answer = null;
        if (IdResponseAnswer != 0)
            answer = Answers.Where(a => a.ChildAnswers.Any(ach => ach.IdAnswer == IdResponseAnswer)).SingleOrDefault();

        int idRootAnswer = -1;
        if (answer != null)
            idRootAnswer = answer.IdAnswer; //Skorygowane id odpowiedzi na jego nadrzędną odpowiedź.

        Tuple<bool, string> result = null;
        if (idRootAnswer != -1)
            result = await answerRepository.AddAnswer(text, 1, idRootAnswer);
        else
            result = await answerRepository.AddAnswer(text, 1, IdResponseAnswer);

        if (!result.Item1)
            await js.InvokeVoidAsync("alert", result.Item2);
        else
        {
            if(IdResponseAnswer == 0)
                await GetAnswers(0, Answers.Count + 1);
            else
                await GetAnswers(0, Answers.Count);
        }
        IdResponseAnswer = 0;
    }

    /// <summary>
    /// Metoda odpowiedzialna za usunięcie odpowiedzi.
    /// </summary>
    /// <param name="answer">Odpowiedź przeznaczona do usunięcia.</param>
    private async Task DeleteAnswer(AnswerResponseDTO answer)
    {
        if (answer.IdRootAnswer == null)
            Answers.Remove(answer);
        else
            Answers.SingleOrDefault(a => a.IdAnswer == answer.IdRootAnswer).ChildAnswers.Remove(answer);
    }

    /// <summary>
    /// Metoda odpowiedzialna za ustawienie id odpowiedzi do której będzie odnosić się nowa odpowiedź.
    /// </summary>
    /// <param name="idAnswer"></param>
    private void setResponseAnswer(int idAnswer)
    {
        if (IdResponseAnswer == idAnswer)
            IdResponseAnswer = 0;
        else
            IdResponseAnswer = idAnswer;
    }

    /// <summary>
    /// Metoda odpowiedzialna za wyczyszczenie tekstu z pola dla nowej odpowiedzi.
    /// </summary>
    private void discard()
    {
        TextAdd = null;
    }

    /// <summary>
    /// Metoda odpowiedzialna za doładowywanie nowych odpowiedzi.
    /// </summary>
    [JSInvokable]
    public async Task LoadMore()
    {
        if (!IsLoading)
        {
            IsLoading = true;
            StateHasChanged();
            var TotalSize = PageNumber * PageSize;
            var answersParams = new AnswersPageDTO
            {
                StartIndex = Answers.Count != TotalSize ? TotalSize - 1: TotalSize,
                PageSize = PageSize
            };
            var newAnswers = await answerRepository.GetAnswersAsync(IdQuestion, answersParams);
            newAnswers.RemoveAll(a => Answers.Any(an => an.IdAnswer == a.IdAnswer));
            Answers.AddRange(newAnswers);
            PageNumber++;

            IsLoading = false;
            StateHasChanged();

            if (newAnswers.Count == 0)
                await js.InvokeVoidAsync("ScrollList.RemoveListener");
        }
    }

    /// <summary>
    /// Metoda odpowiedzialna za załadowanie konkretnych odpowiedzi.
    /// </summary>
    /// <param name="startIndex">Indeks od którego zostaną załadowane odpowiedzi.</param>
    /// <param name="pageSize">Ilość odpowiedzi do załadowania</param>
    private async Task GetAnswers(int startIndex, int answersAmount)
    {
        var answersParams = new AnswersPageDTO
        {
            StartIndex = startIndex,
            PageSize = answersAmount
        };

        var answers = await answerRepository.GetAnswersAsync(IdQuestion, answersParams);
        Answers = answers;
    }

    /// <summary>
    /// Metoda odpowiedzialna za pobranie konkretnej odpowiedzi wraz z listą pododpowiedzi.
    /// </summary>
    /// <param name="idRootAnswer">Id konkrentej odpowiedzi.</param>
    private async Task GetChildAnswers(int idRootAnswer)
    {
        var updatedAnswer = await answerRepository.GetAnswerAsync(idRootAnswer);
        var answer = Answers.SingleOrDefault(a => a.IdAnswer == idRootAnswer);
        answer.Text = updatedAnswer.Text;
        answer.Rating = updatedAnswer.Rating;
        answer.ChildAnswers = updatedAnswer.ChildAnswers;
        answer.AmountOfChildAnswers = updatedAnswer.AmountOfChildAnswers;
    }

}