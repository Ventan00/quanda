@using Quanda.Client.Authentication
@using Quanda.Shared.Enums
@using Blazored.LocalStorage
@inject IAuthenticationService _authenticationService
@inject NavigationManager _navManager
@inject ILocalStorageService _localStorageService
@inject IToastService _toastService

<EditForm Model="@_loginDto" OnValidSubmit="@HandleValidSubmit" autocomplete="off">
    <DataAnnotationsValidator />
    <div class="form-group">
        <label for="email-input" class="d-block">Nickname or Email</label>
        <InputText id="email-input" @bind-Value="_loginDto.NicknameOrEmail" />
        <ValidationMessage For="() => _loginDto.NicknameOrEmail" />
    </div>
    <div class="form-group">
        <label for="password-input" class="d-block">Password</label>
        <InputText id="password-input" @bind-Value="_loginDto.RawPassword" />
        <ValidationMessage For="() => _loginDto.RawPassword" />
    </div>

    @if (_loginStatus == LoginStatusEnum.EMAIL_NOT_CONFIRMED)
    {
        <label class="text-danger d-block">Email address is not confirmed.</label>
        <label>Don't see an email?</label>
        <a class="btn btn-link pl-1" href="recover/email-confirmation">Click here</a>
    }

    <CaptchaComponent @ref="_captchaComponent" />

    @if (_isPending)
    {
        <button type="submit" class="btn btn-dark d-block mt-3" disabled>Logging in...</button>
    }
    else
    {
        <button type="submit" class="btn btn-success d-block mt-3">Log In</button>
    }
</EditForm>

@code {

    /// <summary>
    ///     Model formularza
    /// </summary>
    private readonly LoginDTO _loginDto = new();

    /// <summary>
    ///     Enum zawierający się w odpowiedzi od serwera na próbe zalogowania
    /// </summary>
    private LoginStatusEnum? _loginStatus;

    /// <summary>
    ///     Komponent captcha
    /// </summary>
    private CaptchaComponent _captchaComponent;

    /// <summary>
    ///     Zmienna mowiąca o tym, czy rządanie jest w trakcie realizacji
    /// </summary>
    private bool _isPending;

    /// <summary>
    ///     Metoda wywoływana przy potwierdzeniu prawidłowo wypełnionego formularza logowania
    /// </summary>
    /// <returns></returns>
    private async Task HandleValidSubmit()
    {
        var captchaResponseToken = await _captchaComponent.GetCaptchaResponseAsync();
        if (captchaResponseToken is null)
        {
            _toastService.ShowError("reCaptcha must be completed");
            return;
        }
        _loginDto.CaptchaResponseToken = captchaResponseToken;

        _loginStatus = null;
        _isPending = true;
        StateHasChanged();

        var loginResponseDto = await _authenticationService.LoginAsync(_loginDto);
        await HandleLoginResponse(loginResponseDto.LoginStatus, loginResponseDto.Avatar);

        _isPending = false;
    }

    /// <summary>
    ///     Metoda obsługująca odpowiedz od serwera na wysłany formularz
    /// </summary>
    /// <param name="loginStatusEnum"></param>
    /// <param name="Avatar>
    /// </param>
    /// <returns></returns>
    private async Task HandleLoginResponse(LoginStatusEnum loginStatusEnum, string Avatar)
    {
        _loginStatus = loginStatusEnum;

        switch (loginStatusEnum)
        {
            case LoginStatusEnum.LOGIN_ACCEPTED:
                _toastService.ShowSuccess("You have logged in.");
                await _localStorageService.SetItemAsync("avatar", Avatar);
                _navManager.NavigateTo("");
                return;
            case LoginStatusEnum.INVALID_CREDENTIALS:
                _toastService.ShowError("Invalid credentials. Please try again.");
                break;
            case LoginStatusEnum.INVALID_CAPTCHA:
                _toastService.ShowError("reCaptcha must be completed");
                break;
            case LoginStatusEnum.SERVER_ERROR:
                _toastService.ShowError("An unexpected error has occurred. Please try again.");
                break;
        }

        await _captchaComponent.ResetCaptchaAsync();
    }

}